// Vertex parameters
float2 inverseViewSize;

// Pixel parameters
sampler2D tex : register(s0);

float4 frag[11];
#define scissorMat float3x3(frag[0].xyz, frag[1].xyz, frag[2].xyz)
#define paintMat float3x3(frag[3].xyz, frag[4].xyz, frag[5].xyz)
#define innerCol frag[6]
#define outerCol frag[7]
#define scissorExt frag[8].xy
#define scissorScale frag[8].zw
#define extent frag[9].xy
#define radius frag[9].z
#define feather frag[9].w
#define strokeMult frag[10].x
#define strokeThr frag[10].y

struct VSInput
{
	float2 vertex : POSITION0;
	float2 tcoord : TEXCOORD0;
};

struct VSOutput
{
	float4 position : POSITION0;
	float2 ftcoord : TEXCOORD0;
	float2 fpos : NORMAL0;
};

VSOutput VS(VSInput input)
{
	VSOutput output;
	output.ftcoord = input.tcoord;
	output.fpos = input.vertex;
	output.position = float4(
		2.0 * input.vertex.x * inverseViewSize.x - 1.0,
		1.0 - 2.0 * input.vertex.y * inverseViewSize.y,
		0,
		1
	);
	return output;
}

float sdroundrect(float2 pt, float2 ext, float rad)
{
	float2 ext2 = ext - float2(rad, rad);
	float2 d = abs(pt) - ext2;
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rad;
}

float2 mat3_x_float2(float3x3 m, float2 v)
{
	return float2(
		m[0].x * v.x + m[1].x * v.y + m[2].x,
		m[0].y * v.x + m[1].y * v.y + m[2].y
	);
}

float scissorMask(float2 p)
{
	float2 sc = abs(mat3_x_float2(scissorMat, p)) - scissorExt;
	sc = float2(0.5, 0.5) - sc * scissorScale;
	return clamp(sc.x, 0.0, 1.0) * clamp(sc.y, 0.0, 1.0);
}

float strokeMask(float2 ftcoord)
{
	return min(1.0, (1.0 - abs(ftcoord.x * 2.0 - 1.0)) * strokeMult) * min(1.0, ftcoord.y);
}

// FIXME: The preshaders generated by this are HUGE, optimize them out
float4 PS(
	VSOutput input,
	uniform bool edgeAA,
	uniform int type,
	uniform int texType
) : COLOR0 {
	float scissor = scissorMask(input.fpos);

	float strokeAlpha;
	if (edgeAA)
	{
		strokeAlpha = strokeMask(input.ftcoord);
		if (strokeAlpha < strokeThr) discard;
	}
	else
	{
		strokeAlpha = 1.0f;
	}

	if (type == 0) // Gradient
	{
		// Calculate gradient color using box gradient
		float2 pt = mat3_x_float2(paintMat, input.fpos);
		float d = clamp((sdroundrect(pt, extent, radius) + feather * 0.5) / feather, 0.0, 1.0);
		float4 color = lerp(innerCol, outerCol, d);

		// Combine alpha
		color *= strokeAlpha * scissor;
		return color;
	}
	else if (type == 1) // Image
	{
		// Calculate color fron texture
		float2 pt = mat3_x_float2(paintMat, input.fpos) / extent;
		float4 color = tex2D(tex, pt);
		if (texType == 1) color = float4(color.xyz * color.w, color.w);
		if (texType == 2) color = color.wwww;

		// Apply color tint and alpha.
		color *= innerCol;

		// Combine alpha
		color *= strokeAlpha * scissor;
		return color;
	}
	else if (type == 2) // Stencil fill
	{
		return float4(1, 1, 1, 1);
	}
	else if (type == 3) // Textured tris
	{
		float4 color = tex2D(tex, input.ftcoord);
		if (texType == 1) color = float4(color.xyz * color.w, color.w);
		if (texType == 2) color = color.wwww;
		color *= scissor;
		return color * innerCol;
	}
	discard; // Should never get here!!!
}

technique EdgeAA_Gradient_Premultiplied
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(true, 0, 0);
	}
}

technique EdgeAA_Gradient_Nonpremultiplied
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(true, 0, 1);
	}
}

technique EdgeAA_Gradient_Alpha
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(true, 0, 2);
	}
}

technique EdgeAA_Image_Premultiplied
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(true, 1, 0);
	}
}

technique EdgeAA_Image_Nonpremultiplied
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(true, 1, 1);
	}
}

technique EdgeAA_Image_Alpha
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(true, 1, 2);
	}
}

technique EdgeAA_StencilFill_Premultiplied
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(true, 2, 0);
	}
}

technique EdgeAA_StencilFill_Nonpremultiplied
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(true, 2, 1);
	}
}

technique EdgeAA_StencilFill_Alpha
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(true, 2, 2);
	}
}

technique EdgeAA_Tris_Premultiplied
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(true, 3, 0);
	}
}

technique EdgeAA_Tris_Nonpremultiplied
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(true, 3, 1);
	}
}

technique EdgeAA_Tris_Alpha
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(true, 3, 2);
	}
}

technique NoAA_Gradient_Premultiplied
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(false, 0, 0);
	}
}

technique NoAA_Gradient_Nonpremultiplied
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(false, 0, 1);
	}
}

technique NoAA_Gradient_Alpha
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(false, 0, 2);
	}
}

technique NoAA_Image_Premultiplied
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(false, 1, 0);
	}
}

technique NoAA_Image_Nonpremultiplied
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(false, 1, 1);
	}
}

technique NoAA_Image_Alpha
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(false, 1, 2);
	}
}

technique NoAA_StencilFill_Premultiplied
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(false, 2, 0);
	}
}

technique NoAA_StencilFill_Nonpremultiplied
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(false, 2, 1);
	}
}

technique NoAA_StencilFill_Alpha
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(false, 2, 2);
	}
}

technique NoAA_Tris_Premultiplied
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(false, 3, 0);
	}
}

technique NoAA_Tris_Nonpremultiplied
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(false, 3, 1);
	}
}

technique NoAA_Tris_Alpha
{
	pass P
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS(false, 3, 2);
	}
}
